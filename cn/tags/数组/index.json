[{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":2,"section":"gallery","tags":null,"title":"Cartoon","uri":"http://hexiaopi.github.io/golang-notes/cn/gallery/cartoon/"},{"content":"程序、表达式、运算符之间的关系**\n 通常计算机程序是由多条表达式语句按照一定的逻辑关系所构成的，表达式（Expression）是程序算法的基本单位。\n 表达式\n 表达式由操作数（常量、变量、函数调用等）和运算符结合一起构成的式子；\n 运算符\n 运算符（Operator）用于对操作数进行运算\n根据操作数的数目可分为一元运算符、二元运算符；\n按照运算符的功能可分为赋值运算符、算术运算符、逻辑运算符、关系运算符、位运算符等；\n 1 运算符 1.1 赋值运算符 赋值运算符是把等号右边的操作数（常量、变量、函数调用等）的值赋于等号左边的变量\n赋值运算格式如下：\n1  \u0026lt;变量名称\u0026gt; = \u0026lt;操作数\u0026gt;   也可以在定义变量时同时赋值，格式如下：\n1  var \u0026lt;变量名称\u0026gt; [变量类型] = \u0026lt;操作数\u0026gt;   1.2 算术运算符    运算符 描述 说明     + 加法运算符 操作数可以是整数、浮点数和字符串   - 减法运算符 操作数可以是整数和浮点数   * 乘法运算符 操作数可以是整数和浮点数   / 除法运算符 分母不能位0，操作数为整数即是取整运算   % 取余运算符 操作数为整数，结果为整数    👣\n 乘除法优先级高于加减法 在Go 语言中++、\u0026ndash;是语句而非表达式  1.3 关系运算符 关系运算的实质是比较，运算结果是布尔类型\n   运算符 描述 说明     \u0026gt; 大于 a\u0026gt;b，返回true；否则，返回false   \u0026gt;= 大于等于 a\u0026gt;=b，返回true；否则，返回false   \u0026lt; 小于 a\u0026lt;b，返回true；否则，返回false   \u0026lt;= 小于等于 a\u0026lt;=b，返回true；否则，返回false   == 等于 a==b，返回true；否则，返回false   != 不等于 a!=b，返回true；否则，返回false    1.4 逻辑运算符 逻辑运算符的操作数是bool型\n   运算符 描述 说明     ！ 逻辑非运算符 一元运算符，取反   \u0026amp;\u0026amp; 逻辑与运算符 逻辑与   || 逻辑或运算符 逻辑或    1.5 位运算符 位操作运算符的操作数是整型或byte型\n   运算符 描述 说明     ^ 取反运算符 一元运算符，对操作数按位取反   \u0026amp; 按位与运算符 二元运算符   | 按位或运算符 二元运算符   ^ 按位异或运算符 二元运算符   \u0026amp;^ 标志位清楚运算符 二元运算符   $\u0026laquo;$ 左移运算符 二元运算符   $\u0026raquo;$ 右移运算符 二元运算符    1.6 通道运算符 通道运算符使用“$\u0026lt;-$“接受或者发送数据\n2. 运算符的优先级和结合 运算符优先级共分为7级，由7-\u0026gt;1优先级依次降低\n   优先级 运算符 说明     7 ^ ! 一元运算符   6 * / % \u0026laquo; \u0026raquo; \u0026amp; \u0026amp;^ 二元运算符   5 + - | ^ 二元运算符   4 == != \u0026lt; \u0026lt;= \u0026gt;= \u0026gt; 关系运算符   3 $\u0026lt;-$ 通道运算符   2 \u0026amp;\u0026amp; 逻辑运算符   1 || 逻辑运算符    ","description":"Guide to Golang","id":3,"section":"posts","tags":["运算符","表达式"],"title":"运算符与表达式","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"content":"数组  一个由固定长度的特定类型组成的序列。特定类型可以是：字符串、结构体、函数、接口、通道等。\n 定义 1 2 3 4  var a [3]int\t//长度为3的int类型数组，元素为[0,0,0] var b = [...]int{1,2,3}\t//长度为3的int类型数组，元素为[1,2,3] var c = [...]int{1:2,2:3}\t//长度为3的int类型数组，元素为[0,2,3] var d = [...]int{0,2,2:3,4}\t//长度为4的int类型数组，元素为[0,2,3,4]   👣\n​\t定义数组可以指定长度，例如第1种定义；也可以根据初始化元素的数目自动计算，例如第2、3、4种定义。\n​\t初始化数组元素可以按顺序指定，例如第2种定义；也可以根据索引指定元素，例如第3、4种定义。\n操作 len()  len()函数可以用于计算数组的长度。\n cap()  cap()函数可以用于计算数组的容量。\n 👣\n​\tlen()和cap()对于数组来说，结果始终一致。\n遍历 1 2 3 4 5 6 7 8 9 10 11  for i:=range a{ fmt.Printf(\u0026#34;a[%d]: %d\\n\u0026#34;,i,a[i]) } for i,v:=range a{ fmt.Printf(\u0026#34;a[%d]: %d\\n\u0026#34;,i,v) } for i:=0;i\u0026lt;len(a);i++{ fmt.Printf(\u0026#34;a[%d]: %d\\n\u0026#34;,i,a[i]) }   👣\n for range方式迭代可以保证不会出现数组越界的情况。 数组的定义包含长度，因此长度不同的数组，即便类型一致，整个数组仍不是同一类型。 长度为0的数组（空数组）在内存中并不占用空间。  切片  切片（slice）简称动态数组，既然是动态，切片的长度可以动态伸缩。\n 切片的结构定义，即reflect.SliceHeader:\n1 2 3 4 5  type SliceHeader struct{ Data uintptr Len int Cap int }   切片的定义包含三个字段：\n 第一个字段是切片指向的底层数组； 第二个字段表示切片的长度 第三个字段表示切片的容量  定义 1 2 3 4 5 6 7 8 9 10 11  var ( a []int\t// nil切片，表示不存在的切片 \tb = []int{}\t// 空切片，不等于nil，表示空的集合 \tc = []int{1,2,3}\t// 指向包含三个元素的数组：[1，2，3]。len和cap为3 \td = c[:2]\t// 与c指向同一个数组，但是len为2，cap为3 \te = c[0:2:cap(c)]\t// 与c指向同一个数组，但是len为2，cap为cap(c)的大小，即3 \tf = c[:0]\t// 与c指向同一个数组，但是len为0，cap为3 \tg = make([]int,3)\t// 指向新的数组，包含三个元素：[0,0,0]。len和cap为3 \th = make([]int,2,3)\t// 指向新的数组，包含三个元素：[0,0,0]。len为2，cap为3 \ti = make([]int,0,3)\t// 指向新的数组，包含三个元素：[0,0,0]。len为0，cap为3 )   👣\n​\t切片的容量必须大于等于切片的长度。\n操作 和数组类似，可以使用len()和cap()函数获取切片的长度和容量。此外可以使用append()对切片追加元素，但append()远不止这个功能。\n1. 添加切片元素 在切片尾部追加元素： 1 2 3 4  var a []int\t//为nil a = append(a,1)\t//追加一个元素，len和cap都为1 a = append(a,2,3,4)\t//追加三个元素，len和cap都为4 a = append(a []int{5,6,7}...)\t//追加一个切片，len为7，cap为8   在追加元素过程中，如果容量不足，append()操作会导致重新分配内存，例如第二行对为nil的切片申请空间，但申请的内存并不一定为所需的空间，如第四行。\n在切片头部追加元素： 1 2 3  var a = []int{1,2,3}\t//len和cap都为3 a = append([]int{0},a...)\t//在开头添加一个元素，len和cap都为4 a = append([]int{-3,-2,-1},a...)\t//在开头添加一个切片，len为7，cap为8   在切片开头追加元素会导致内存的重新分配，已有的元素会复制一份。因此从切片的头部追加元素的性能很差，也很少使用到。\n在切片中间追加元素： 1 2 3  var a = []int{1,2,7} a = append(a[:2],append([]int{3},a[2:]...)...) //追加一个元素，现在包含元素[1,2,3,7] a = append(a[:3],append([]int{4,5,6},a[3:]...)...)\t//追加一个切片，现在包含元素[1,2,3,4,5,6,7]   同样，在切片中间追加元素，会创建许多临时切片，性能比较差。可以使用copy()函数完成类似的功能：\n1 2 3 4  var a = []int{1,2,4}\t// [1,2,4],cap=3 a = append(a,0)\t// [1,2,4,0],cap=6 copy(a[3:],a[2:])\t// [1,2,0,4],cap=6 a[2] = 3\t// [1,2,3,4],cap=6   copy(target,source)函数，将source的内容复制到target，相比较append，节省了临时切片的创建。\n2. 删除切片元素 在切片头部删除元素 1 2  var a = []int{1,2,3}\t// [1,2,3],len=3,cap=3 a = append([]int{},a[1:]...) // [2,3],len=2,cap=2   这里的len和cap都为2，是因为重新分配了内存空间\n在切片中部删除元素 1 2  var a = []int{1,2,3,4}\t// [1,2,3,4],len=4,cap=4 a = append(a[:1],a[2:]...)\t// [1,3,4],len=3,cap=4   在切片尾部删除元素 1 2  var a = []int{1,2,3}\t// [1,2,3],len=3,cap=3 a = a[:2]\t// [2,3],len=2,cap=3   删除尾部一个元素：a = a[:len(a)-1]\n删除尾部N个元素：a = a[:len(a)-N]\n","description":"Guide to Golang","id":4,"section":"posts","tags":["数组"],"title":"数组","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"},{"content":" Go语言基本数据类型（Data-types）包括布尔型、整型、浮点型、复数型、字节型、指针类型。\n 1、布尔型数据(Boolean) **关键字定义：**bool\n**字节长度：**1\n取值范围：[true、false]\n**零值：**false\n👣\n 布尔类型不接受其他数据类型赋值； 布尔类型不能进行强制类型转换；  2、整型数据（Integer） 整型数据类型分为：有符号整型、无符号整型\n   类型 字节长度 取值范围     int 4/8 32位系统即int32，64位系统即int64   int8 1 $-2^7$~$2^7-1$   int16 2 $-2^{15}$~$2^{15}-1$   int32 4 $-2^{31}$~$2^{31}-1$   int64 8 $-2^{63}$~$2^{63}-1$   uint 4/8 32位系统即uint32，64位系统即uint64   uint8 1 0~$2^8-1$   uint16 2 0~$2^{16}-1$   uint32 4 0~$2^{32}-1$   uint64 8 0~$2^{64}-1$    **零值：**对应字节长度的0\n👣\n 由于字节范围的限制，尤其需注意“溢出”问题，可使用math包中“Max”和“Min”开头的常量帮组检查溢出；  整型数据的表示方法：\n 十进制，如$-123$、0、256； 八进制，以“0”开头的数是八进制，如0123表示八进制数123，即十进制的83； 十六进制，以“0x”开头的数是十六进制数，如0x123表示十六进制数123，即十进制的291； 指数形式，由数字和字母$e$组成，如$1e3$或$10e2$代表十进制的1000；  3、浮点型数据（Floating-point-number） 浮点型数据，也称为实数（Real-number），可存储带有小数的数值。浮点型数据在内存中的存储形式和整数不同，是按照指数形式存储的，共有三部分组成：符号、尾数和指数。\n   类型 字节长度 精确位数     float32 4 精确小数点后7位   float64 8 精确小数点后15位    **零值：**0\n浮点型数据的表示方法：\n 十进制小数形式：由数字和小数点组成，如1.57、0.12、0.0都是十进制的小数形式； 指数形式：由数字和字母$e$组成，如$1.23e3$或$12.3e2$都表示$1.23\\times10^3$；字母$e$之前必须有数字且后面的指数必须为整数；  👣\n 浮点型数据是由有限的存数单元组成的，能提供有效数字总是有限的，有效位以外的数字将被舍去，可能存在一些误差；  4、复数（Complex-number）  复数是由两个浮点数构成，一个表示实部（real），一个表示虚部（imag），形式如$a+bi$的数，这里的$a$、$b$是实数，$i$是虚数单位\n    类型 字节长度 说明     complex64 8 由两个float32构成，因此字节长度为4+4   complex128 16 由两个float64构成，因此字节长度为8+8    对于一个复数$z=complex(x,y)$，可以通过Go语言内置函数$real(z)$获得该复数的实部，也可以通过函数$imag(z)$获得该复数的虚部；\n**零值：**0+0i\n5、字节型数据（Byte）  字节型数据在计算机中主要是来表示和存储ASCII码，即处理字符，将一个字符存放到一个字符变量中，实际上并不是把该字符本身存放到内存单元中，而是将该字符的ASCII编码存放到内存单元中。\n **关键字定义：**byte\n**字节长度：**1\n取值范围：[0~$2^8-1$]，byte本质就是uint8。\n**零值：**0\n6、rune类型  Go语言处理Unicode字符有个专用的数据类型rune，等价于int32。\n Unicode编码\n 随着计算机技术在世界范围内的广泛使用，国际标准化组织（ISO）统一制定了一种可以容纳世界上所有文字和符号的字符编码方案，即Unicode编码方案。由于涉及到不同计算机架构的大小端问题（Big Endian，Little Endian）于是存在不同的Unicode字符集转换格式（UCS Transformation Format,UTF)，例如：\n UTF-8：使用1～4B不等长方案，西方字符通常只用一个字节，中文通常需要三个字节； UTF-16：用2B无符号整数存储Unicode字符； UTF-32：用4B无符号整数存储Unicode字符；   7、uintptr类型  Go语言中，uintptr是可以保存32位或64位的指针的无符号整数类型，和int类型一样，uintptr根据操作系统决定指针位数，32位操纵系统uintptr是32位的，64位操作系统uintptr是64位的。\n ","description":"Guide to Golang","id":5,"section":"posts","tags":["数据类型"],"title":"数据类型","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"content":"1 常量 常量（constant），顾名思义，程序运行期间，其值不能改变的量。\n1.1 定义 const \u0026lt;constant_name\u0026gt; [constant_type] = \u0026lt;赋值表达式\u0026gt; 定义一个\n1 2 3 4  const PI float32 = 3.1415926 //编译器自动推断类型 const str = \u0026#34;Go\u0026#34; //自动推断为string类型   定义多个\n1  const a, b, c = 1, \u0026#34;Go\u0026#34;, \u0026#39;c\u0026#39; //自动推断a是整型、b是字符串类型、c是字节型   定义常量组\n1 2 3 4 5  const ( COLON = \u0026#34;:\u0026#34; EMPTY = \u0026#34;\u0026#34; ) //Go的标准库有很多这种写法，例如http/status.go声明了许多http状态码。   1.2 初始化 规则：\n 常量值必须是确定的，不能使用程序运行期间不确定的值； 常量组中，若不提供初始化值，则默认表示使用上行的赋值表达式；  1.3 枚举  枚举，一组常量值，通常用于限定值的范围。\n 例如：\n1 2 3 4 5 6 7 8 9  const ( Sunday = iota //0 \tMonday = iota //1 \tTuesday = iota //2 \tWednesday = iota //3 \tThursday = iota //4 \tFriday = iota //5 \tSaturday = iota //6 )   规则说明：\n 常量组每定义一个常量iota就会自动递增1； 每遇到一个const关键字，iota就会重置为0； 如果按行递增（如上例所示），可省略后续的iota关键字；  Example：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  package main import \u0026#34;fmt\u0026#34; const ( a = \u0026#39;A\u0026#39; b c = iota d ) const ( e = \u0026#39;E\u0026#39; f = iota ) func main() { fmt.Println(a, b, c, d, e, f) } //Output //65 65 2 3 69 1   2. 变量 程序运行过程中，其值可以改变的量称为变量（variable）。\n2.1 定义 1  var \u0026lt;variable_name\u0026gt; [variable_type]   定义一个\nvar count int 定义多个\n1 2 3 4  var ( i int s string )   定义短变量\n1  count := 10   👣\n 短变量声明只可存在函数中，不可全局声明 由于使用了:=，因此至少有一个新声明的变量出现在左值，否则编译失败  定义匿名变量\n 匿名变量是以下划线_声明的，通常用于忽略某个值\n 2.2 变量的类型 变量的类型划分方式比较多，这里按照变量的数据类型进行划分：值类型、复合类型、引用类型\n值类型\n 值类型即基本的数据类型，包括布尔类型（bool）、整型（int）、浮点型（float）、字节型（byte）、复数型（complex）、字符串型（string）和错误类型（error）。\n值类型的变量在传递过程中，编译器对该变量的值进行一次拷贝。\n 复合类型\n 复合类型即比较复杂的数据类型，包括数组（array）今儿结构体（struct）。数组里存放的是一组相同类型的数据，结构体里存放的是不同类型的数据。\n与值类型一致，复合类型变量在传递过程也是进行值拷贝。\n 引用类型\n 引用类型即指针类型，包括指针（pointer）、切片（silence）、字典（map）、通道（channel）、接口（interface）和函数（function）。\n 👣\n值类型和引用类型的区别在于，在函数参数传递过程中\n 值类型的变量的值复制一份传递 引用类型的变量是把自己的内存地址传递  2.3 变量的零值 Go语言中，当一个变量被定义为某一种数据类型后，Go语言回自动初始化其值为零值（Zero Value），零值并不等于空值，而是对应数据类型的默认值。\n 通常情况下默认值为“0” 布尔类型的默认值是false 字符串类型的默认值为空字符串 其他类型为nil，表示没有分配内存地址  2.4 变量的作用域 变量的作用（使用）范围称为变量的作用域，通常来说，一段程序代码中所用到的变量并不总是有效或可用的，而限定这个变量的可用范围即作用域，根据作用域可将变量分为两种：全局变量和局部作变量。\n作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了命名冲突。\n全局变量\n 全局变量（Global Variables）是在函数外部定义的变量，它的作用范围涵盖了整个包。\n 局部变量\n 局部变量（Local Variables）是在函数内部定于的变量，它的作用范围仅限域函数内部。\n 3. 命名规则  Go语言中用来对符号常量、变量、函数、数组、切片、通道等数据对象命名的有效字符序列统称为标识符（Identifier）即数据对象的名字。\n Go语言的命名规则：\n 变量名必须以字母或下划线开始； 必须使用英文字母、数字、下划线组成，不能出现空格或制表符； 不能使用Go语言内置关键字和保留字，如go、goto、break等； 大小写敏感，比如x和X是两个不一样的标识符；  ","description":"Guide to Golang","id":6,"section":"posts","tags":["常量","变量"],"title":"常量、变量及命名规则","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F%E5%8F%8A%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"},{"content":"当下载完Go安装包后，需设置3个环境变量，分别是：\n GOROOR：Go语言安装根目录的路径，这是下载的Go语言安装路径。 GOPATH：工作区目录的路径，这是我们写代码存放的地方。 GOBIN：Go程序生成的可执行文件的路径。  可使用命令go env来查看当前的设置。\n这里重点关注GOPATH，因为这是我们项目存放的地方，且需按照Go语言的源码组织方式组织我们的项目。GOPATH包含多个工作区，每个工作区包含三个文件夹，分别是：\n src：Go语言的源码文件（source file）。 pkg：安装后的归档文件（archive file），即程序编译后生产的静态库文件。同时会根据操作系统和计算机架构生产平台相关目录，例如是linux_amd64则表示是Linux系统，CPU是amd64架构。 bin：可执行文件（executable file）。  ","description":"开发应用工程结构目录","id":7,"section":"posts","tags":["结构"],"title":"工程结构","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84/"},{"content":"Go语言的字符串（String）\n1 定义 **关键字定义：**string\n零值：“”\n1  var str string   👣\n 字符串的内容可以用类似数组下标的方式获取，例如str[0]，但与数组不同，字符串的内容初始化后不可修改，只能重新构造新的字符串，带来的好处是线程安全； Go语言支持UTF-8格式编码，因此字符串中字符可以是ASCII字符，也可以是Unicode字符； Go语言字符串可使用内置函数len()来计算ASCII字符的长度，可以使用utf8.RuneCountInString()来计算Unicode字符的长度；  2 操作 字符串支持一些简单的运算或操作，如下：\n   操作 含义 示例 结果     x+y 字符串连接 \u0026ldquo;Go\u0026rdquo;+\u0026ldquo;lang\u0026rdquo; \u0026ldquo;Golang\u0026rdquo;   len(x) 计算字符串长度 len(\u0026ldquo;Golang\u0026rdquo;) 6   str[i] 取字符 \u0026ldquo;Golang\u0026rdquo;[3] a    3 遍历 由于字符可以使用两种方式表示：byte来表示ASCII字符，rune来表示Unicode字符；因此Go字符串遍历也支持两种方式：byte和rune\n3.1 byte遍历 1 2 3  for i:=0;i\u0026lt;len(str);i++{ fmt.Println(i,string(str[i])) }   3.2 rune遍历 1 2 3  for i,s:=range str{ fmt.Println(i,string(s)) }   ","description":"字符串相关内容","id":8,"section":"posts","tags":["字符串"],"title":"字符串","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"content":"Go语言是一种开源的静态型、编译型并自带垃圾回收和并发的程序设计语言。  具有以下特点：\n1、快速编译\n开发人员经常导入一些头文件（include），但是有些内容并未使用，导致编译了不必要的内容，Go语言会在编译时检查判断程序和包之间的联系，如果没有联系则报告异常，从而减少编译内容，加快编译速度。\n2、并发设计简单\nGo语言原生支持并发、无须使用第三方库。Go语言的并发模型基于CSP模型，使用goroutine轻量级线程实现并发，使用channel实现各个goroutine之间的通信。\n3、垃圾回收\nGo语言使用了一个简单的标记-清除算法实现了高效快速垃圾回收，帮组开发者无须关心内存问题。\n4、工程规范\nGo语言使用统一的UTF-8编码进行开发，减少因为编码问题导致的一些问题。\nGo语言的项目工程简单，无须解决方案、工程文件和Make File。\nGolang学习帮助\n https://golang.orgGo语言官方网站，提供完善的参考文档；国内访问https://golang.google.cn/ https://blog.golang.orgGo语言官方博客，不定期发布一些Go 语言实践文章； http://talks.golang.org收录了各种报告的讲稿；  ","description":"Guide to Golang","id":9,"section":"posts","tags":null,"title":"简介","uri":"http://hexiaopi.github.io/golang-notes/cn/posts/%E7%AE%80%E4%BB%8B/"},{"content":" 这是一个学习Go语言的博客\n想通过博客的方式记录自己的Go学习之旅\n同样也希望帮助到喜欢Go的童鞋，有问题欢迎交流哈~\n ","description":"About Page","id":10,"section":"","tags":null,"title":"关于","uri":"http://hexiaopi.github.io/golang-notes/cn/about/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":11,"section":"gallery","tags":null,"title":"Photo","uri":"http://hexiaopi.github.io/golang-notes/cn/gallery/photo/"}]